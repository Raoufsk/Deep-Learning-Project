# -*- coding: utf-8 -*-
"""MLP_v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J1JQS9mpqi14OTmNiWQ8fjmMH99TB5WS
"""

import keras
import numpy as np
import pandas as pd
import tensorflow as tf
import matplotlib.pyplot as plt

from keras import layers
from keras import regularizers
from keras.layers import Dropout
from keras.utils import np_utils
from sklearn import preprocessing
from keras.models import Sequential
from sklearn.utils import class_weight
from sklearn.impute import SimpleImputer
from keras.callbacks import EarlyStopping
from tensorflow.keras.optimizers import SGD, Adam
from keras.layers import Input, Dense, Activation
from sklearn.metrics import confusion_matrix as cm
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report as cr

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/drive/MyDrive/preprocessed_file_v1_filtered', 
                 compression = "zip", header = 0, index_col = 0, sep = "\t")

df = df.replace("Unknown", np.nan)
df = df.replace("Not Applicable", np.nan)
df = df.replace("Not Collected", np.nan)
df = df.replace("Not collected", np.nan)
df = df.replace("Not Released", np.nan)

data = df.drop("CANCER_TYPE", axis = 1)
labels = df["CANCER_TYPE"]

for x in data[["SEX", "ETHNICITY", "PRIMARY_RACE", "DEAD"]]:
    data[x], _ = pd.factorize(data[x])

imp = SimpleImputer(missing_values = np.nan, strategy = "constant", fill_value = -1)
data[["YEAR_CONTACT", "YEAR_DEATH"]] = imp.fit_transform(data[["YEAR_CONTACT", "YEAR_DEATH"]])
imp = SimpleImputer(missing_values = '>89', strategy = "constant", fill_value = -1)
data[["YEAR_CONTACT", "YEAR_DEATH"]] = imp.fit_transform(data[["YEAR_CONTACT", "YEAR_DEATH"]])
imp = SimpleImputer(missing_values = '<18', strategy = "constant", fill_value = -1)
data[["YEAR_CONTACT", "YEAR_DEATH"]] = imp.fit_transform(data[["YEAR_CONTACT", "YEAR_DEATH"]])

data

data = data.astype(int)

print(labels.unique(), len(labels.unique()))

encoder = preprocessing.LabelEncoder()
classes = encoder.fit_transform(labels)

x_train, x_test, y_train, y_test = train_test_split(
									data, classes, 
									test_size = 0.2, 
									random_state = 0) 

print(y_train.shape)
print(x_train.shape)
print(y_test.shape)
print(x_test.shape)

learning_rate = 0.01
opt = 'ADAM'
hidden_drop = 0.3
lambda_l1 = 0.01
lambda_l2 = 0.02
size_batch = 128
nb_epochs = 50

model = Sequential()	
	
model.add(	
	Dense(64, input_dim = len(data.columns), activation = 'relu'))

model.add(Dropout(hidden_drop))

model.add(	
	Dense(32, activation = 'relu'))

model.add(Dropout(hidden_drop))
	
model.add(	
	Dense(len(labels.unique()), activation = 'softmax'))
	
model.compile(optimizer = opt,	
						loss = 'sparse_categorical_crossentropy',	
						metrics = ["accuracy"])

model.summary()

es = EarlyStopping(
  monitor = 'val_accuracy', mode = 'max', 
	verbose = 1, patience = 30)

class_weights = class_weight.compute_class_weight(class_weight="balanced", classes=np.unique(y_train), y=y_train)
class_weights_d = {l:c for l,c in zip(np.unique(y_train), class_weights)}

print(class_weights_d)

history = model.fit(
	x_train, y_train, 
	validation_data = (x_test, y_test), 
	batch_size = size_batch, 
  epochs = nb_epochs, 
  class_weight = class_weights_d,
	verbose = 1, callbacks = [es])

metrics = ['loss', 'accuracy']
for n, metric in enumerate(metrics):
  name = metric.replace("_"," ").capitalize()
  plt.subplot(2,2,n+1)
  plt.plot(history.epoch, history.history[metric],  label='Train')
  plt.plot(history.epoch, history.history['val_'+metric], linestyle="--", label='Val')
  plt.xlabel('Epoch')
  plt.ylabel(name)
  if metric == 'loss':
    plt.ylim([0, plt.ylim()[1]])
  elif metric == 'auc':
    plt.ylim([0.8,1])
  else:
    plt.ylim([0,1])

  plt.legend()